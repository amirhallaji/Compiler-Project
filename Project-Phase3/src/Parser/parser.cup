package Parser;

import java_cup.runtime.*;

import AST.*;

parser code {:
//    public Laxer laxer;
//    public parser (Laxer laxer){
//        this.laxer = laxer;
//    }
//    @Override
//    protected void report_expected_token_ids(){ }

    protected Program root;

    void setRoot(Program p) { this.root = p; }

    public Program getRoot() { return this.root; }
:}
//scan with {:return laxer.next_token();:}
//init with {::}


/* terminals */

//reserved Words terminals
terminal VOID, INT, DOUBLE,BOOL,STRING;
terminal CLASS, INTERFACE, NULL, THIS, EXTENDS;
terminal IMPLEMENTS, FOR, WHILE, IF, ELSE;
terminal RETURN, BREAK, NEW, NEWARRAY, PRINT;
terminal READINTEGER, READLINE,DTOI,ITOD, BTOI,ITOB;
terminal PRIVATE, PROTECTED,PUBLIC, CONTINUE;


//condition Symbols
terminal EQUAL, NOTEQUAL, LESSEQUAL, LESS, GREATER, GREATEREQUAL;
terminal AND,NOT,OR;

//Arithmitic symbols
terminal DIV, PROD, ADD,MINUS,MOD;

//other symbols
terminal ASSIGN, COLON, COMMA, LBRACK,RBRACK , LRBRACK; // BRACK []
terminal DOT,LBRACES, RBRACES, LCURLY, RCURLY;// BRACES () CURLY{}

// identifier
terminal String ID;

//constants 
terminal Integer INTCONST;
terminal String HEXCONST;
terminal Double DOUBLECONST;
terminal String STRINGCONST;
terminal Boolean TRUE;
terminal Boolean FALSE;

/**/

/* Non terminals */

//whole program nonterminal
nonterminal ASTNode program;

// declarations
nonterminal ASTNode decl;
// Types of declarations
nonterminal ASTNode variableDecl;
nonterminal ASTNode functionDecl;
nonterminal ASTNode classDecl;
nonterminal ASTNode interfaceDecl;
nonterminal ASTNode variableDecl_plus;
// define variable
nonterminal ASTNode variable;
// types of definitions except void
nonterminal ASTNode type;
// args of functions
nonterminal ASTNode formals;
//statement block
nonterminal ASTNode stmtBlock;
// methods and variables in class
nonterminal ASTNode field;
nonterminal ASTNode field_plus;
//public or private of protected
nonterminal ASTNode accessMode;
//protoypes in interface
nonterminal ASTNode prototype;
nonterminal ASTNode prototype_plus;
// id1, id2, .... (minimum 1 id)
nonterminal ASTNode id_plus;
//statement
nonterminal ASTNode stmt;
nonterminal ASTNode stmt_plus;
//IF and While and for
nonterminal ASTNode ifStmt;
nonterminal ASTNode whileStmt;
nonterminal ASTNode forStmt;
// break continue return print
nonterminal ASTNode breakStmt;
nonterminal ASTNode continueStmt;
nonterminal ASTNode printStmt;
nonterminal ASTNode returnStmt;
//expressions
nonterminal ASTNode expr;
nonterminal ASTNode expr_plus;

nonterminal ASTNode lValue;

nonterminal ASTNode constant;

nonterminal ASTNode call;

nonterminal ASTNode actuals;

nonterminal ASTNode identifier; 

/**/

/* precedence  */
precedence left COMMA;
precedence nonassoc ASSIGN;
precedence left AND, OR ;
precedence left EQUAL, NOTEQUAL ;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left ADD, MINUS;
precedence left PROD, DIV, MOD;
precedence right NOT;
precedence right LBRACES, RBRACES,LBRACK,RBRACK;
/**/

start with program;


program  ::= program:p decl:t
        {:
           RESULT = p;
           RESULT.addChild(t);
        :}
           | decl:t
           {: 
                RESULT = new Program();
                RESULT.addChild(t);
                setRoot((Program)RESULT);
            :};

decl ::= variableDecl:t
           {: RESULT = t; :}
       | functionDecl:t
           {: RESULT = t; :}
       | classDecl:t
           {: RESULT = t; :}
       | interfaceDecl:t
           {: RESULT = t; :}; 

variableDecl ::= 
    variable:v COLON
        {: RESULT = v; :};

variableDecl_plus ::= 
                variableDecl_plus:vp variableDecl:v
                    {://TODO
                    :}
                | variableDecl:v
                    {: //TODO
                    :};

variable ::= type:t identifier:i
             {: 
                RESULT = new BaseASTNode(NodeType.VARIABLE_DECLARATION);
                RESULT.addChild(t);
                RESULT.addChild(i);
                t.setParent(RESULT);
                i.setParent(RESULT);
            :};
type ::= 
        INT
            {: RESULT = new TypeNode(NodeType.INT_TYPE, PrimitiveType.INT); :}
       | DOUBLE
            {: RESULT = new TypeNode(NodeType.DOUBLE_TYPE, PrimitiveType.DOUBLE); :}
       | BOOL
            {: RESULT = new TypeNode(NodeType.BOOLEAN_TYPE, PrimitiveType.BOOL); :}
       | STRING
            {: RESULT = new TypeNode(NodeType.STRING_TYPE, PrimitiveType.STRING); :}
       | identifier:t
            {: RESULT = t; :}
       | type LRBRACK
            {:
            //TODO 
            :};

functionDecl ::= type:t identifier:i LBRACES formals:f RBRACES stmtBlock:s
         {:
			RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
			RESULT.addChild(t, i, f, s);
			t.setParent(RESULT);
			i.setParent(RESULT);
			f.setParent(RESULT);
			s.setParent(RESULT);
        :}
               | VOID identifier:i LBRACES formals:f RBRACES stmtBlock:s
         {:
            RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
            ASTNode t = new TypeNode(NodeType.VOID, PrimitiveType.VOID); 
            RESULT.addChild(t, i, f, s);
            t.setParent(RESULT);
            i.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :}
               | type:t identifier:i LBRACES RBRACES stmtBlock:s
         {:
            RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
            ASTNode f = new BaseASTNode(NodeType.ARGUMENTS);
            RESULT.addChild(t, i, f, s);
            t.setParent(RESULT);
            i.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :}
               | VOID identifier:i LBRACES RBRACES stmtBlock:s
        {:
            RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
            ASTNode t = new TypeNode(NodeType.VOID, PrimitiveType.VOID); 
            ASTNode f = new BaseASTNode(NodeType.ARGUMENTS);
            RESULT.addChild(t, i, f, s);
            t.setParent(RESULT);
            i.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :};

formals ::=  variable:v COMMA formals:f
            {:
                RESULT = f;
                ASTNode a = new BaseASTNode(NodeType.ARGUMENT);
                RESULT.addChild(a);
                a.setParent(RESULT);
                a.addChild(v);
                v.setParent(a);
            :}
           | variable:v
            {:
                RESULT = new BaseASTNode(NodeType.ARGUMENTS);
                ASTNode a = new BaseASTNode(NodeType.ARGUMENT);
                RESULT.addChild(a);
                a.setParent(RESULT);
                a.addChild(v);
                v.setParent(a);
            :}  ;

classDecl ::= CLASS identifier:i1 LCURLY field_plus:fs  RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 LCURLY field_plus:fs RCURLY
            | CLASS identifier:i1 IMPLEMENTS id_plus  LCURLY field_plus  RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 IMPLEMENTS id_plus LCURLY field_plus RCURLY
            | CLASS identifier:i1 LCURLY RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 LCURLY RCURLY
            | CLASS identifier:i1 IMPLEMENTS id_plus  LCURLY RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 IMPLEMENTS id_plus LCURLY RCURLY;

id_plus ::= ID
          | ID COMMA id_plus ;

field_plus ::= field_plus field
             | field;

field ::= accessMode variableDecl
        | variableDecl
        | accessMode functionDecl
        | functionDecl;

accessMode ::= PRIVATE | PROTECTED | PUBLIC  ;

interfaceDecl ::= INTERFACE ID LCURLY RCURLY
                | INTERFACE ID LCURLY prototype_plus RCURLY;

prototype_plus ::= prototype_plus prototype
                 | prototype;
prototype ::= type ID LBRACES formals RBRACES COLON
             | VOID ID LBRACES formals RBRACES COLON
             | type ID LBRACES RBRACES COLON
             | VOID ID LBRACES RBRACES COLON;

stmtBlock ::= LCURLY RCURLY
            | LCURLY variableDecl_plus RCURLY
            | LCURLY stmt_plus RCURLY
            | LCURLY variableDecl_plus stmt_plus RCURLY;

stmt_plus ::= stmt_plus stmt
            | stmt;

stmt ::= expr COLON | COLON | ifStmt | whileStmt | forStmt
            | breakStmt | continueStmt | returnStmt | printStmt
            | stmtBlock ;

ifStmt ::= IF LBRACES expr RBRACES  stmt
         | IF LBRACES expr RBRACES stmt ELSE stmt;

whileStmt::= WHILE LBRACES expr RBRACES stmt;

forStmt ::= FOR LBRACES COLON expr COLON RBRACES stmt
          | FOR LBRACES expr COLON expr COLON RBRACES stmt
          | FOR LBRACES  COLON expr COLON expr RBRACES stmt
          | FOR LBRACES expr COLON expr COLON expr RBRACES stmt;

returnStmt ::= RETURN COLON
             | RETURN expr COLON;

breakStmt ::= BREAK COLON;

continueStmt ::= CONTINUE COLON;

printStmt ::= PRINT LBRACES expr_plus RBRACES COLON;

expr_plus ::= expr COMMA expr
            | expr ;


expr ::= lValue ASSIGN expr | constant | lValue
        | THIS | call | LBRACES expr RBRACES
        | expr ADD expr | expr MINUS expr | expr PROD expr
        | expr DIV expr | expr MOD expr | MINUS expr
        | expr LESS expr | expr LESSEQUAL expr
        | expr GREATER expr | expr GREATEREQUAL expr
        | expr EQUAL expr | expr NOTEQUAL expr
        | expr AND expr | expr OR expr | NOT expr
        | READINTEGER LBRACES RBRACES
        | READLINE LBRACES RBRACES
        | NEW ID | NEWARRAY LBRACES expr COMMA type RBRACES
        | ITOD LBRACES expr RBRACES | DTOI LBRACES expr RBRACES
        | ITOB LBRACES expr RBRACES | BTOI LBRACES expr RBRACES;

lValue ::= ID | expr DOT ID | expr LBRACK expr RBRACK;

call ::= ID LBRACES actuals RBRACES | expr DOT ID LBRACES actuals RBRACES
         ID LBRACES  RBRACES | expr DOT ID LBRACES RBRACES;

actuals ::= expr_plus;

constant ::= 
    INTCONST:i
        {: RESULT = new IntegerLiteralNode(i); :} 
    | DOUBLECONST:d
        // {: RESULT = new DoubleLiteralNode(d); :} 
    | HEXCONST:h
        // {: RESULT = new HexLiteralNode(h); :}
    | TRUE
        {: RESULT = new BooleanLiteralNode(true); :}    
    | FALSE 
        {: RESULT = new BooleanLiteralNode(false); :}
    | STRINGCONST:s
        {: RESULT = new StringLiteralNode(s); :}
    | NULL;
        // {: RESULT = new BaseASTNode(NodeType.NULL_LITERAL); :};


identifier ::=
    ID:i
        {: RESULT = new IdentifierNode(i); :};