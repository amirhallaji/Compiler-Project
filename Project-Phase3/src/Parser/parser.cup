package Parser;

import java_cup.runtime.*;

import AST.*;

parser code {:
//    public Laxer laxer;
//    public parser (Laxer laxer){
//        this.laxer = laxer;
//    }
//    @Override
//    protected void report_expected_token_ids(){ }

    protected Program root;

    void setRoot(Program p) { this.root = p; }

    public Program getRoot() { return this.root; }
:}
//scan with {:return laxer.next_token();:}
//init with {::}


/* terminals */

//reserved Words terminals
terminal VOID, INT, DOUBLE,BOOL,STRING;
terminal CLASS, INTERFACE, NULL, THIS, EXTENDS;
terminal IMPLEMENTS, FOR, WHILE, IF, ELSE;
terminal RETURN, BREAK, NEW, NEWARRAY, PRINT;
terminal READINTEGER, READLINE,DTOI,ITOD, BTOI,ITOB;
terminal PRIVATE, PROTECTED,PUBLIC, CONTINUE;


//condition Symbols
terminal EQUAL, NOTEQUAL, LESSEQUAL, LESS, GREATER, GREATEREQUAL;
terminal AND,NOT,OR;

//Arithmitic symbols
terminal DIV, PROD, ADD,MINUS,MOD;

//other symbols
terminal ASSIGN, COLON, COMMA, LBRACK,RBRACK , LRBRACK; // BRACK []
terminal DOT,LBRACES, RBRACES, LCURLY, RCURLY;// BRACES () CURLY{}

// identifier
terminal String ID;

//constants 
terminal Integer INTCONST;
terminal String HEXCONST;
terminal Float DOUBLECONST;
terminal String STRINGCONST;
terminal Boolean TRUE;
terminal Boolean FALSE;

/**/

/* Non terminals */

//whole program nonterminal
nonterminal ASTNode program;

// declarations
nonterminal ASTNode decl;
// Types of declarations
nonterminal ASTNode variableDecl;
nonterminal ASTNode functionDecl;
nonterminal ASTNode classDecl;
nonterminal ASTNode interfaceDecl;
nonterminal ASTNode variableDecl_plus;
// define variable
nonterminal ASTNode variable;
// types of definitions except void
nonterminal ASTNode type;
// args of functions
nonterminal ASTNode formals;
//statement block
nonterminal ASTNode stmtBlock;
// methods and variables in class
nonterminal ASTNode field;
nonterminal ASTNode field_plus;
//public or private of protected
nonterminal ASTNode accessMode;
//protoypes in interface
nonterminal ASTNode prototype;
nonterminal ASTNode prototype_plus;
// id1, id2, .... (minimum 1 id)
nonterminal ASTNode id_plus;
//statement
nonterminal ASTNode stmt;
nonterminal ASTNode stmt_plus;
//IF and While and for
nonterminal ASTNode ifStmt;
nonterminal ASTNode whileStmt;
nonterminal ASTNode forStmt;
// break continue return print
nonterminal ASTNode breakStmt;
nonterminal ASTNode continueStmt;
nonterminal ASTNode printStmt;
nonterminal ASTNode returnStmt;
//expressions
nonterminal ASTNode expr;
nonterminal ASTNode expr_plus;

nonterminal ASTNode lValue;

nonterminal ASTNode constant;

nonterminal ASTNode call;

nonterminal ASTNode actuals;

nonterminal ASTNode identifier; 

/**/

/* precedence  */
precedence left COMMA;
precedence nonassoc ASSIGN;
precedence left AND, OR ;
precedence left EQUAL, NOTEQUAL ;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left ADD, MINUS;
precedence left PROD, DIV, MOD;
precedence right NOT;
precedence right LBRACES, RBRACES,LBRACK,RBRACK;
/**/

start with program;


program  ::= program:p decl:t
        {:
           RESULT = p;
           RESULT.addChild(t);
        :}
           | decl:t
           {: 
                RESULT = new Program();
                RESULT.addChild(t);
                setRoot((Program)RESULT);
            :};

decl ::= variableDecl:t
           {: RESULT = t; :}
       | functionDecl:t
           {: RESULT = t; :}
       | classDecl:t
           {: RESULT = t; :}
       | interfaceDecl:t
           {: RESULT = t; :}; 

variableDecl ::= 
    variable:v COLON
        {: RESULT = v; :};

variableDecl_plus ::= 
                variableDecl_plus:vp variableDecl:v
                    {://TODO
                    :}
                | variableDecl:v
                    {: //TODO
                    :};

variable ::= type:t identifier:i
             {: 
                RESULT = new BaseASTNode(NodeType.VARIABLE_DECLARATION);
                RESULT.addChild(t);
                RESULT.addChild(i);
                t.setParent(RESULT);
                i.setParent(RESULT);
            :};
type ::= 
        INT
            {: RESULT = new TypeNode(NodeType.INT_TYPE, PrimitiveType.INT); :}
       | DOUBLE
            {: RESULT = new TypeNode(NodeType.DOUBLE_TYPE, PrimitiveType.DOUBLE); :}
       | BOOL
            {: RESULT = new TypeNode(NodeType.BOOLEAN_TYPE, PrimitiveType.BOOL); :}
       | STRING
            {: RESULT = new TypeNode(NodeType.STRING_TYPE, PrimitiveType.STRING); :}
       | identifier:t
            {: RESULT = t; :}
       | type LRBRACK
            {:
            //TODO 
            :};

functionDecl ::= type:t identifier:i LBRACES formals:f RBRACES stmtBlock:s
         {:
			RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
			RESULT.addChild(t, i, f, s);
			t.setParent(RESULT);
			i.setParent(RESULT);
			f.setParent(RESULT);
			s.setParent(RESULT);
        :}
               | VOID identifier:i LBRACES formals:f RBRACES stmtBlock:s
         {:
            RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
            ASTNode t = new TypeNode(NodeType.VOID, PrimitiveType.VOID); 
            RESULT.addChild(t, i, f, s);
            t.setParent(RESULT);
            i.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :}
               | type:t identifier:i LBRACES RBRACES stmtBlock:s
         {:
            RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
            ASTNode f = new BaseASTNode(NodeType.ARGUMENTS);
            RESULT.addChild(t, i, f, s);
            t.setParent(RESULT);
            i.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :}
               | VOID identifier:i LBRACES RBRACES stmtBlock:s
        {:
            RESULT = new BaseASTNode(NodeType.METHOD_DECLARATION);
            ASTNode t = new TypeNode(NodeType.VOID, PrimitiveType.VOID); 
            ASTNode f = new BaseASTNode(NodeType.ARGUMENTS);
            RESULT.addChild(t, i, f, s);
            t.setParent(RESULT);
            i.setParent(RESULT);
            f.setParent(RESULT);
            s.setParent(RESULT);
        :};

formals ::=  variable:v COMMA formals:f
            {:
                RESULT = f;
                ASTNode a = new BaseASTNode(NodeType.ARGUMENT);
                RESULT.addChild(a);
                a.setParent(RESULT);
                a.addChild(v);
                v.setParent(a);
            :}
           | variable:v
            {:
                RESULT = new BaseASTNode(NodeType.ARGUMENTS);
                ASTNode a = new BaseASTNode(NodeType.ARGUMENT);
                RESULT.addChild(a);
                a.setParent(RESULT);
                a.addChild(v);
                v.setParent(a);
            :}  ;
//TODO
classDecl ::= CLASS identifier:i1 LCURLY field_plus:fs  RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 LCURLY field_plus:fs RCURLY
            | CLASS identifier:i1 IMPLEMENTS id_plus  LCURLY field_plus  RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 IMPLEMENTS id_plus LCURLY field_plus RCURLY
            | CLASS identifier:i1 LCURLY RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 LCURLY RCURLY
            | CLASS identifier:i1 IMPLEMENTS id_plus  LCURLY RCURLY
            | CLASS identifier:i1 EXTENDS identifier:i2 IMPLEMENTS id_plus LCURLY RCURLY;

id_plus ::= ID
          | ID COMMA id_plus ;

field_plus ::= field_plus field
             | field;

field ::= accessMode variableDecl
        | variableDecl
        | accessMode functionDecl
        | functionDecl;

accessMode ::= PRIVATE | PROTECTED | PUBLIC  ;

interfaceDecl ::= INTERFACE ID LCURLY RCURLY
                | INTERFACE ID LCURLY prototype_plus RCURLY;

prototype_plus ::= prototype_plus prototype
                 | prototype;
prototype ::= type ID LBRACES formals RBRACES COLON
             | VOID ID LBRACES formals RBRACES COLON
             | type ID LBRACES RBRACES COLON
             | VOID ID LBRACES RBRACES COLON;
//TODO
stmtBlock ::=
             LCURLY RCURLY
                {:
                    RESULT = new BaseASTNode(NodeType.BLOCK);
                :}
            | LCURLY variableDecl_plus:vs RCURLY
                {:
                 RESULT = new BaseASTNode(NodeType.BLOCK);
                 RESULT.addChild(vs);
                 vs.setParent(RESULT);
                :}
            | LCURLY stmt_plus:sp RCURLY
                {: 
                RESULT = new BaseASTNode(NodeType.BLOCK); 
                RESULT.addChild(sp);
                sp.setParent(RESULT);
                :}
            | LCURLY variableDecl_plus:vs stmt_plus:sp RCURLY
                {: 
                 RESULT = new BaseASTNode(NodeType.BLOCK);
                 RESULT.addChild(vs);
                 RESULT.addChild(sp);
                 vs.setParent(RESULT);
                 sp.setParent(RESULT); 
                :};

stmt_plus ::= stmt_plus:sp stmt:s
             {: 
                 RESULT = sp;
                 RESULT.addChild(s);
                 s.setParent(RESULT); 
             :}

            | stmt:s
              {: 
                 RESULT = new BaseASTNode(NodeType.STATEMENTS);
                 RESULT.addChild(s);
                 s.setParent(RESULT); 
             :};


stmt ::= 
        expr:e COLON 
         {: 
            RESULT = e;
         :}
        | COLON 
          {: 
            RESULT = new BaseASTNode(NodeType.EMPTY_STATEMENT);
          :}
        | ifStmt: ifs 
         {: 
           RESULT = ifs;
         :}
        | whileStmt :whs
         {: 
           RESULT = whs;
         :}
        | forStmt :fs
         {: 
           RESULT = fs;
         :}
        | breakStmt :bs
         {: 
           RESULT = bs;
         :}
        | continueStmt :cs
         {: 
           RESULT = cs;
         :}
        | returnStmt:rs 
         {: 
           RESULT = rs;
         :}
        | printStmt:ps
         {: 
           RESULT = ps;
         :}
        | stmtBlock : sb
         {: 
           RESULT = sb;
         :};

ifStmt ::= 
        IF LBRACES expr:e RBRACES  stmt:s
            {:
                RESULT = new BaseASTNode(NodeType.IF_STATEMENT);
                RESULT.addChild(e, s);
                e.setParent(RESULT);
                s.setParent(RESULT);
            :}
         | IF LBRACES expr:e RBRACES stmt:s1 ELSE stmt:s2
              {:
                RESULT = new BaseASTNode(NodeType.IF_STATEMENT);
                RESULT.addChild(e, s1,s2);
                e.setParent(RESULT);
                s1.setParent(RESULT);
                s2.setParent(RESULT);
             :};

whileStmt::= 
        WHILE LBRACES expr:e RBRACES stmt:s
          {:
            RESULT = new BaseASTNode(NodeType.WHILE_STATEMENT);
            RESULT.addChild(e, s);
            e.setParent(RESULT);
            s.setParent(RESULT);
         :};

forStmt ::= 
            FOR LBRACES COLON expr:e COLON RBRACES stmt:s
            {:
                RESULT = new BaseASTNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e, s);
                e.setParent(RESULT);
                s.setParent(RESULT);
            :}
          | FOR LBRACES expr:e1 COLON expr:e2 COLON RBRACES stmt:s
            {:
                RESULT = new BaseASTNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e1,e2,s);
                e1.setParent(RESULT);
                e2.setParent(RESULT);
                s.setParent(RESULT);
            :}
          | FOR LBRACES COLON expr:e1 COLON expr:e2 RBRACES stmt:s
            {:
                RESULT = new BaseASTNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e1,s,e2);
                e1.setParent(RESULT);
                e2.setParent(RESULT);
                s.setParent(RESULT);
            :}
          | FOR LBRACES expr:e1 COLON expr:e2 COLON expr:e3 RBRACES stmt:s
            {:
                RESULT = new BaseASTNode(NodeType.FOR_STATEMENT);
                RESULT.addChild(e1,e2,s,e3);
                e1.setParent(RESULT);
                e2.setParent(RESULT);
                e3.setParent(RESULT);
                s.setParent(RESULT);
            :};

returnStmt ::= 
            RETURN COLON
                {:
                    RESULT = new BaseASTNode(NodeType.RETURN_STATEMENT);
                :}
             |RETURN expr:e COLON
                {:
                    RESULT = new BaseASTNode(NodeType.RETURN_STATEMENT);
                    RESULT.addChild(e);
                    e.setParent(RESULT);
                :};
                

breakStmt ::= 
            BREAK COLON
                {:
                    RESULT = new BaseASTNode(NodeType.BREAK_STATEMENT);
                :};

continueStmt ::= 
            CONTINUE COLON
                {:
                    RESULT = new BaseASTNode(NodeType.CONTINUE_STATEMENT);
                :};

printStmt ::= 
            PRINT LBRACES expr_plus:es RBRACES COLON
                {:
                    RESULT = new BaseASTNode(NodeType.PRINT_STATEMENT);
                    RESULT.addChild(es);
                    es.setParent(RESULT);
                :};

expr_plus ::= 
            expr:e1 COMMA expr:e2
                {:
                    RESULT = e1;
                    RESULT.addChild(e2);
                    e2.setParent(RESULT);
                :}
            | expr:e1
                {:
                    RESULT = new ExpressionNode();
                    RESULT.addChild(e1);
                    e1.setParent(RESULT);
                :}; 


expr ::= 
        lValue:l ASSIGN expr:e
         {:
            RESULT = new ExpressionNode();
            RESULT.addChild(l);
            RESULT.addChild(e);
            l.setParent(RESULT);
            e.setParent(RESULT);
        :}
        | constant:c
        {:
            RESULT = new ExpressionNode();
            RESULT.addChild(c);
            c.setParent(RESULT);
        :}
        | lValue:l
        {:
            RESULT = new ExpressionNode();
            RESULT.addChild(l);
            l.setParent(RESULT);

        :}
        | THIS
        {:
            RESULT = new ExpressionNode();
            ASTNode t = new BaseASTNode(NodeType.THIS);
            RESULT.addChild(t);
            t.setParent(RESULT);
        :} 
        | call:c
         {:
            RESULT = new ExpressionNode();
            RESULT.addChild(c);
            c.setParent(RESULT);
        :}
        | LBRACES expr RBRACES
        | expr ADD expr | expr MINUS expr | expr PROD expr
        | expr DIV expr | expr MOD expr | MINUS expr
        | expr LESS expr | expr LESSEQUAL expr
        | expr GREATER expr | expr GREATEREQUAL expr
        | expr EQUAL expr | expr NOTEQUAL expr
        | expr AND expr | expr OR expr | NOT expr
        | READINTEGER LBRACES RBRACES
        | READLINE LBRACES RBRACES
        | NEW ID | NEWARRAY LBRACES expr COMMA type RBRACES
        | ITOD LBRACES expr RBRACES | DTOI LBRACES expr RBRACES
        | ITOB LBRACES expr RBRACES | BTOI LBRACES expr RBRACES;

lValue ::= ID | expr DOT ID | expr LBRACK expr RBRACK;

call ::= ID LBRACES actuals RBRACES | expr DOT ID LBRACES actuals RBRACES
         ID LBRACES  RBRACES | expr DOT ID LBRACES RBRACES;

actuals ::= expr_plus;

constant ::= 
    INTCONST:i
        {: RESULT = new IntegerLiteralNode(i); :} 
    | DOUBLECONST:d
        {: RESULT = new DoubleLiteralNode(d); :} 
    | HEXCONST:h
        // {: RESULT = new HexLiteralNode(h); :}
    | TRUE
        {: RESULT = new BooleanLiteralNode(true); :}    
    | FALSE 
        {: RESULT = new BooleanLiteralNode(false); :}
    | STRINGCONST:s
        {: RESULT = new StringLiteralNode(s); :}
    | NULL
        {: RESULT = new BaseASTNode(NodeType.NULL_LITERAL); :};


identifier ::=
    ID:i
        {: RESULT = new IdentifierNode(i); :};